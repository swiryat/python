import pandas as pd
import numpy as np
import datetime as dt
import seaborn as sns
import matplotlib.pyplot as plt
from scipy.stats import shapiro
from scipy.stats import kstest
from scipy.stats import ks_2samp
from scipy.stats import anderson
from scipy.stats import jarque_bera
from scipy.stats import ttest_ind
from scipy.stats import mannwhitneyu
from scipy.stats import kruskal
df = pd.read_csv('8.csv')
df
df.info()
def swap(x:str):
    if x.isdigit():
        return float(x)
df['Звонков ночью за месяц'] = df['Звонков ночью за месяц'].apply(swap)
df['Звонки в другие города'] = df['Звонки в другие города'].apply(swap)
df['Доля звонков на стационарные телефоны'] = df['Доля звонков на стационарные телефоны'].apply(swap)
df.info()
df['Дата подключения тарифа'] = pd.to_datetime(df['Дата подключения тарифа'], errors='coerce')
df['Год подключения'] = df['Дата подключения тарифа'].dt.year

def проверить_нормальность(столбец, alpha=0.05):
    _, p_value = shapiro(df[столбец].dropna())
    if p_value <= alpha:
        print(f"Нулевая гипотеза о нормальности распределения для признака '{столбец}' отвергается.")
    else:
        print(f"Нулевая гипотеза о нормальности распределения для признака '{столбец}' принимается.")

# Проверка нормальности для 'Звонков днем за месяц'
проверить_нормальность('Звонков днем за месяц')

# Проверка нормальности для 'Звонков вечером за месяц'
проверить_нормальность('Звонков вечером за месяц')

# Выполнение теста Колмогорова-Смирнова для двух выборок
# H_0 -- 'Звонков днем за месяц' и 'Звонков вечером за месяц' имеют одинаковые распределения
# H_1 -- 'Звонков днем за месяц' и 'Звонков вечером за месяц' имеют разные распределения
ks_statistic, ks_p_value = ks_2samp(df['Звонков днем за месяц'].dropna(), df['Звонков вечером за месяц'].dropna())
print(f"KS-статистика: {ks_statistic}, P-значение: {ks_p_value}")

# Выполнение теста нормальности с использованием kstest для 'Звонков днем за месяц'
среднее_звонков_днем = df['Звонков днем за месяц'].mean()
стандартное_отклонение_звонков_днем = df['Звонков днем за месяц'].std()
ks_result_day_calls = kstest(df['Звонков днем за месяц'].dropna(), 'norm', args=(среднее_звонков_днем, стандартное_отклонение_звонков_днем))
print(f"KS-статистика для 'Звонков днем за месяц': {ks_result_day_calls.statistic}, P-значение: {ks_result_day_calls.pvalue}")
sns.histplot(data=df,
             x=df['Звонков днем за месяц'])
# Проверяем гипотезу о равенстве параметров
# клиенты чаще звонят днем или вечером по количеству звонков;
# Н0: Отсутствует статистически значимая разница между количество звонков, совершаемых клиентом днем и вечером.
# Н0: Разница между количество звонков, совершаемых клиентом днем и вечером, статистически незначима.
# H1: Количество звонков, совершаемых клиентами днем, меньше количества звонков, совершаемых клиентами вечером
# используем односторонний критерий -- левосторонний или меньше

# если бы
# клиенты одинаково звонят днем и вечером по количеству звонков;
# Н0: Отсутствует статистически значимая разница между количество звонков, совершаемых клиентом днем и вечером.
# H1: Разница между количество звонков, совершаемых клиентом днем и вечером, статистически значима.
# и тогда используется двусторонний критерий

print(df['Звонков днем за месяц'].dropna().mean(), df['Звонков вечером за месяц'].dropna().mean())
#Важно, гипотезу H1 формулируют отталкиваясь от значений параметром (выборочное среднее, медиана)
#H1: Количество звонков, совершаемых клиентами днем, меньше количества звонков, совершаемых клиентами вечером

# Загрузка
# Профилирование
# Предобработка
# Исследовательский анализ - EDA
# Проверка гипотез
mannwhitneyu(df['Звонков днем за месяц'],
             df['Звонков вечером за месяц'],
             alternative='less',
             nan_policy='omit')
# клиенты больше звонили в 2019 году по сравнению с 2021 годом по количеству звонков.

df['общее_количество_звонков_за_месяц'] = df['Звонков вечером за месяц']
+ df['Звонков днем за месяц'] + df['Звонков ночью за месяц']

df
#для биноминальных распределений
def test_z_criterion(col, goal, alpha):
    import scipy.stats as st
    import math
    gen_group_shape = df[col].value_counts()
    goal_group_shape = df.groupby(col)[goal].sum()
    p = goal_group_shape / gen_group_shape
    p_combined = goal_group_shape.sum() / gen_group_shape.sum()
    difference = p.iloc[0] - p.iloc[1]
    z_value = difference / math.sqrt(p_combined * (1 - p_combined) * (1/gen_group_shape.iloc[0] + 1/gen_group_shape.iloc[1]))
    distr = st.norm(0, 1)
    p_value = (1 - distr.cdf(abs(z_value))) * 2
    print('Результаты проверки гипотезы H_0 по z-критерию:')
    print('Уровень значимости alpha={:.2f}'.format(alpha))
    print('P-value: {:.2f}'.format(p_value))
    if p_value < alpha:
        print(f"""Отвергаем нулевую гипотезу: разница в долях
по признаку <<{col}>> статистически значима.""")
    else: print(f"""Не получилось отвергнуть нулевую гипотезу: разница в долях по
признаку <<{col}>> статистически незначима.""")
    print('------------------------------------------------------------')
# Печать информации о DataFrame, включая названия столбцов и типы данных
print(df.info())

# Печать первых нескольких строк DataFrame для визуальной проверки данных
print(df.head())
df = pd.read_csv('8.csv')

# Функция для проведения t-теста между двумя группами
def t_test(feature1, feature2):
    _, p_value = ttest_ind(df[feature1].dropna(), df[feature2].dropna())
    return p_value

# Список признаков, между которыми вы хотите сравнить распределения
features = ['Звонков днем за месяц', 'Звонков вечером за месяц']

# Построение матрицы гипотез
hypothesis_matrix = pd.DataFrame(index=features, columns=features)

for feature1 in features:
    for feature2 in features:
        p_value = t_test(feature1, feature2)
        hypothesis_matrix.loc[feature1, feature2] = p_value

# Вывод матрицы гипотез
print("Матрица гипотез:")
print(hypothesis_matrix)
# Преобразование столбцов 'Звонки в другие города', 'Доля звонков на стационарные телефоны'
# и 'Количество SMS за месяц' в числовой формат с использованием метода pd.to_numeric.
# В случае возникновения ошибок (например, если данные в этих столбцах не являются числовыми),
# параметр errors='coerce' преобразует некорректные значения в NaN.

df['Звонки в другие города'] = pd.to_numeric(df['Звонки в другие города'], errors='coerce')
df['Доля звонков на стационарные телефоны'] = pd.to_numeric(df['Доля звонков на стационарные телефоны'], errors='coerce')
df['Количество SMS за месяц'] = pd.to_numeric(df['Количество SMS за месяц'], errors='coerce')

# Преобразование столбца 'Дата подключения тарифа' в тип datetime с использованием метода pd.to_datetime.
df['Дата подключения тарифа'] = pd.to_datetime(df['Дата подключения тарифа'])

# Гипотеза 1: клиенты чаще звонят днем или вечером по количеству звонков.
# Для этого рассчитывается среднее количество звонков днем и вечером.
hypothesis_1 = df[['Звонков днем за месяц', 'Звонков вечером за месяц']].mean()
print("Гипотеза 1:", hypothesis_1)

# Гипотеза 2: клиенты чаще звонят днем или (вечером + ночью) по количеству звонков.
# Сначала столбец 'Звонков ночью за месяц' преобразуется в числовой формат,
# затем рассчитывается среднее количество звонков днем, вечером и ночью.
df['Звонков ночью за месяц'] = pd.to_numeric(df['Звонков ночью за месяц'], errors='coerce')
hypothesis_2 = df[['Звонков днем за месяц', 'Звонков вечером за месяц', 'Звонков ночью за месяц']].mean()
print("Гипотеза 2:", hypothesis_2)

# Гипотеза 3: клиенты больше звонили в 2019 году по сравнению с 2021 годом по количеству звонков.
# Для этого добавляется столбец 'Год', в котором содержится год из столбца 'Дата подключения тарифа',
# и затем рассчитывается суммарное количество звонков днем за месяц для каждого года.
df['Год'] = df['Дата подключения тарифа'].dt.year
hypothesis_3 = df.groupby('Год')['Звонков днем за месяц'].sum()
print("Гипотеза 3:", hypothesis_3)

# Построение матрицы корреляции для всех признаков, кроме 'Дата подключения тарифа'.
corr_matrix = df.drop('Дата подключения тарифа', axis=1).corr()

# Визуализация матрицы корреляции с помощью тепловой карты (heatmap) с использованием библиотек seaborn и matplotlib.
plt.figure(figsize=(10, 8))
sns.heatmap(corr_matrix, annot=True, cmap='coolwarm', fmt=".2f")
plt.title('Матрица корреляции')
plt.show()

